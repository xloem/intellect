okay.  let's use repetition to debug this.  is fine to restart debugging if needed, could
be prevented with be-conscious form parts.

-> q not stopping
-> reproduce bug [x]
-> trace context near loop call.  seems to be being regenerated
	trace context near loop call.  seems to be being regenerated.
			^--- maybe this non-stabilized reference is related to error spread.
	trace context <> loop call.  seems to be being regenerated.
	trace context either in the whilesteps code or in the mainloop stephabit.  seems to be being regenerated.
	trace context either in the whilesteps code or in the mainloop stephabit.  seems to be being regenerated.
	trace context <> loop call.  seems to be being regenerated.
	trace context in the mainloop stephabit.  seems to be being regenarted?
	considering: review code near the mainloop stephabit.  somewhere a loop is opened, and the context within the loop differs.
	trace context in the mainloop stephabit.  it is differing with that inside the whilesteps stephabit.
	put a breakpoint in loopbody, and examine its return position to find the context within mainloop.  why does returning from whilesteps alter the context pointer?


		[check if step-breakpoints would help.  urge to implement exists.]

-> in loopbody
	ctx = 0x_90d0
-> in call_with_ctx
	ctx = 0x_90d0
-> in habit.hpp:206, steps_next lambda
	subcontext = 0x_90d0 <- for loopbody
	ctx = 0x_8790 <- for caller
		[sym::next was set from the callee, may be a bug]
-> in call_with_ctx
	context = 0x_8ce0, differing from 0x_8790
-> in steps_run
	subcontext = 0x_8ce0
		it looks like outputs aren't being copied into the steps run context
		steps_start uses an outer wrapping context; so does steps_next
		steps_run does not.  this appears the most relevent error; one other error
		may have been encountered.
			nopte: this looks correct.  it is also wrapped within steps_run,
			steps_run has its own side context.
	context = 0x_8790 <- same for caller as in habit.hpp
		note: this context does not have sym::what set.
		and: another loop ran before steps_run returned
	so in summary, it looks like the value was properly passed to the context for
	calling the function that checks it.  time to run through again.

-> whilesteps runs before anything else, to check if should keep running.
	whilesteps ctx: 0x5_5d8790
-> backtrace from whileloop
	call_with_ctx: 0x5_5d8790
	call_with_ctx: 0x5_5d8790
	we end up in whilesteps, line 61 of habits.hpp
	whilesteps: 0x5_5d8790 [ctx[sym::what] == nothing == 0x5_5adee0]
	okay, in the next iteration of whilesteps, ctx has changed.
	it is now 0x5_5d9120.  so the next breakpoints should be in whilesteps, to see why
	their context is changing.
okay.  bug appears found by inspection.
	whilesteps is a normal step, so it is given a subcontext.  it has no outputs, so
	its condition isn't preserved.  if the condition were an output and an input, it
	would be preserved.  flow tracking would have found the issue by complaining when
	data produced by work goes unused.
[bug not resolved.]
	[could it be because sym::what is nothing, the value is not overridden in the return?
		note: flow tracking, setting a variable to nothing has importance, and needs
		preservation and flow]
			[intersects with set-to-nothing-erases, and non-present-resolves-to-nothing]
			[problem is =nothing does nothing to left-hand side, and doesn't backflow.]
				[flow can attach to variables.  can support nothing as data.]
-> sym::what wiped
	ctx = 0x5_5d9230
-> drops back to whilesteps
	whilesteps is using outer ctx of 0x5_5d88f0
	ctx[sym::what] == nothing .
-> in act::steps_next . this should be where we see the flow of ctx[sym::what]
	the next item should have been reset to the whilesteps call
	subcontext = 0x5_5d88f0
		-> the whilesteps call had no outputs, so nothing was preserved from its
		   subcontext.  [which means it would have been caught by dataflow.]
		-> whilesteps is specified with outputs.  something went wrong.
		inside steps_next, the action being called has no outputs.
		it is 31<habit>, and its inputs are 2: "what", "steps"
			okay.  act::whilesteps itself is specified with no outputs,
			becuase it was designed to use the same context, and we gimmicked
			it to use a subcontext for a quick fix.
now fixed.
		the gimmick was due to exhaustion inside a fixing subprocess.
		preparing for multiple nested errors inside debugging, might help.
		might even change how we code.  maybe more tests of parts, and simplification
		of high level structures, to be easy to look at and not require a lot of thought
		to use together.

trying out numbing hunger to continue.

building next steps:
	- smooth out current work (middle-relevencish) so that fewer errors
		- dataflow.
				i moved sym::from into call_with_ctx but
				the output contexts are pretty verbose now
				and show an issue where step_context has a null key, which shouldn't happen.
					in a step-driven environment this would relate to null values being fromable.  but the value deosn't come from habits.
						okay, the issue is that step_context is actually the nothing object.  the output format made this unclear.
			->[ ] catch unused outputs, helps with flow issues
				after a call, we'd ensure the context has no outputs that are not in the outputs specification
			[function call log idea]

		- for-side: variable wraps rather than mutates
		- for-side: separate step-variables from specification-variables?  for thinking while debugging
		- produce small chunk that runs.  test not passed yet.
		- considering: type-checking.  would reduce errors. (1 identified)
			type-checking can also aid in matching variables when generating habits
		- considering: make-most-habits-text, to comprehend dump output
		- considering: function pointers / class methods over std::function.med-high return.
		- considering: wrapped values in contexts.  for not mutating values to tag them.
		- considering: more clear dump format (1 delay): name looked like key
		- discarded: literal special case.  return too small


	considering focus management, kinda
	let's build a bridge so we can cross the river.  meanwhile ...
		-> bridge to cross river
		-> getting bricks
		-> eating food
		-> communicating with bridge-people
		each one has a life-shape-goal, that relates with the whole ongoing process.
			[a community[basically] that stewards how to use it now, given why it is a good idea]
		okay! bridge-goal-people, over there.  bricks-getting-people, over there.
		eating-food-people, over there.  eating-food, you say that we need to steward karl's personal life better?  so much that we should act on it now if we can ... and you say that there appears to be a general way to do anything that's a good idea?  we are in that way now, right?
				[above process is analogous, direct process defeats it]
				[karl's-life-needs not included in piano-practice-ai.]
		[karl's-life-needs-people, over there.
		 ai-people, over there.
			piano-practice-group
			other-group
				i need you to fight me, to do anything.  [oh]
				[you also appear to be expressing high-priority-emergency,know-how-to-do-this-and-can-do-it-now]
					[so we would have other-group fight karl's-life-needs.]
						[i am so confused.  let's organize this better]
		 write-]
[BLARGH! our decision making processes!]
	[i don't want to fight you.  i'm not as strong as you and you look upset.]
[okay, so that group decided to work on ai right now.  hunger is still retriggering but now it is in decisions.]
	[i want to writhe a bit then.]

review on do-flow-next: debugging this took too long to be considered caused by effective choice.
	do-flow-next needs addition that reduces complexity errors.
			-> variables overlap with nonvariable symbols, could make errors
			^-- maybe this can help.  also considering general what-to-do.

		[once bug found: would flow tracking have resolved these bugs, by complaining if return values are unused?] [for flow tracking: when value is produced, add to pool.  when value is mutated, remove from pool, and add new values, linked to old values.]
[this error is big.  please organize parts to reduce further similar errors, after it is fixed.]
					  ^---- middle relevence

		[also note: error tracking raises dataflow tracking: adding flow tracking
		 to scripting could severely aid script debugging.]

HEY OLD STUFF IS BORING: THIS IS VERY SLOW UP HERE DUE TO LACK OF BUILT PRACTICE.
	try doing right-after-small please
		planning this.
		smallest is start from nothing
		after-with-meaning would mean work off of just-started, or smallest-working
		let's try just using ref class.
	
	[note: contexts can be tracked with the sym::outer attribute]

we are taking slow to not make harm. got a nontranslated expression, negativity associated.
	rep says, piano-practice getting growing-harmed.  time for break.
		hrrrrrm  want to do basic-small.
		accepting break, has grown in the past.




	[am i there?  my plan-to-continue involves massive error spread / distraction handling.]
		[practice smaller parts.]

	distraction: i always want to lubricate my eye.  this is appreciated, supported,
	distraction.
