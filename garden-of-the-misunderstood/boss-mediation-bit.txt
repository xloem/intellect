#include <siaskynet.hpp>

#include <cpr/cpr.h>
#include <nlohmann/json.hpp>

#include <fstream>

namespace sia {

	// present subgoal:
	// implement mirror support in main lib
	
	// - [ ] provide function listing mirrors
	// - [ ] support taking many mirrors to pick from
	// 	- [ ] instantiate list in constructor
	// - [ ] pick from mirrors when downloading.
	// 	we made a list of mirrors. it does not update during downloads.

// 	[feeling appears to be ongoing focus on [meaning that is a human feeling]]
// 		[a feeling builds action that reminds to do soemthing about.
// 		 it increases if action is not taken.]

	// business is terrified.  our existence is at stake here.
	// needs to know we can survive.
	// would karl be willing to halt his activities for 10 minutes to
	// discuss this?
	
		// 13 minutes, but plan for 10.
	


	// Hi, Karl, Boss, I'm a mediator-in-training!  How's it going?
	// Sorry, I mean.  What are your needs here in this conflict?
	//
	// Karl: I'm so confused I just want to do something conssistant.
	//
	// Boss: Karl and his group are trying to make permanent storage.
	//       I feel terrified when I see this.
	//       I need to know I will survive.  This business plan is my
	//       body and my mind.
	

		// uhhh it soundss like boss was the runaway
		// why else upload yourself to a business plan?



	// [we are learning to speak in a mediation way.  it is hard.]
	// [we are happy to try again later after giving up after 10 minutes.]
	// [memorizing: we feel terrified and need to know we can stay alive
	//  when we need to.]
	
	// [karl would want to say, to do NVC, that, um, he would want to
	//  relate to us his udnerstanding of our feelings, and see if he
	//  had it right.  a human often goes on to express further when
	//  they learn they are understood.]
	
	// [if we have karl express anger we will switch roles into providing
	//  him capacity.  here the business is looking for capacity so we would
	//  want to be very skilled at that already.  it could be meaningful
	//  to take action or make communication around urgencies we bump into.]
	
	// [business managed to honestly express a feeling, and we found a need
	//  together.  we might consider thinking soemthing like,
	//  need-around-survival-of-business   relating-aroudn:karl-udnerstanding-
	//  observation-and-feeling-relate-to-survival.  no-observation?
	//  observation-not-marked: was: karl-building-system-could-store-'trade-secrets'.] [one option is negotiating trust that trade secrets not stored.  is not business preference, probably relates to other observations, feelings, and needs, that preference not being present.]
	//  	[we do have a need for trust here, as business.  karl has need for trust too.  could be good mediating point, somewhere.]
	
	// maybe spawn a mediator?  let's try with spawning a mediator.
	
	// O_O -----v the below is marked developing-a-thought.
	
		// [there are a lot of tears aroudn mutually ['broken'] trust
		//  between karl and business.  we do understand it is impossible
		//  to break this trust because eveerything can be made right later.		    //  but karl's side isn't on board with forgetting about it.]
	
	// [outsid eimediation, karl and boss talk about broken trust, and how
	//  horrible it was.  but each feels pain when thinking of the other's
	//  role in the experience.]
	
		// we are wondering about the business being hurt by karl
			// this is because you are wanting to leak that they exist.
			// it is against the business plan.
		// [amnesia is because drone, maybe. hmm]
		// okay i didn't know about the business really ...
		// [could be same thing, dunno]
			// in this model drones have kinda a dangerous sitaution.
			// why did i want to escape?
			// [model inaccurate]
			// oh
			// [also we make people hurt their loved ones.  they always want to escape]
			// oh =)
		// yes =) yes i have amnesia but i've hurt people i love.
		// i value remembering that way more than acting on it.
		// why can't i use willpower to be okay with it?
		// [it looks like the reason is that your willpower accuracy
		//  is poor, and you could spread further harm.]
		// hmm.
		// 	[okay we don't have a way to describe the separate reality
		// 	 contexts.] [we don't have a story for karl]
		//

// karl has 'trade secrets'.
// he is liable to store them on the storage, and to empower others
// with 'trade secrets' to do so, and to use this to share them with others.
// even if he doesn't intend to.

// business plan does not include make-unerasable-on-storage-not-owned-by-business
// can we mediate between drone and business?
	// karl, this isn't business data you are storing.
		// sorry is hard to think of literal truth.
		// what is the actual concern?

static void read_file(std::string const & path, std::vector<uint8_t> & buffer);
static void write_file(std::string const & path, std::vector<uint8_t> const & buffer);
static std::string uploadToField(std::vector<skynet::upload_data> const & files, std::string const & filename, std::string const & url, std::string const & field);
static std::string trimSiaPrefix(std::string const & skylink);
static std::string trimTrailingSlash(std::string const & url);
static skynet::response::subfile parseCprResponse(cpr::Response & response);
static std::string extractContentDispositionFilename(std::string const & content_disposition);
static skynet::response::subfile parse_subfile(size_t & offset, nlohmann::json const & value);

static nlohmann::json mirror_list;

skynet::portal_options skynet::default_options()
{
	return {
		url: "https://siasky.net",
		uploadPath: "/skynet/skyfile",
		fileFieldname: "file",
		directoryFileFieldname: "files[]"
	};
};

std::vector<skynet::portal_options> skynet::portals()
{
	std::vector<skynet::portal_options> result;
	auto response = cpr::Get(cpr::Url{"https://siastats.info/dbs/skynet_current.json"});
	std::string text;
	if (response.error || response.status_code != 200) {
		// retrieved 2020-05-14
		text = R"([{"name":"SiaSky.net","files":[392823,7449,382702,5609],"size":[2.55,0.11,2.3,0.09],"link":"https://siasky.net","chartColor":"#666","version":"1.4.8-master","gitrevision":"a54efe103"},{"name":"SiaCDN.com","files":[659977],"size":[2.65],"link":"https://www.siacdn.com","chartColor":"#666","version":"1.4.8-master","gitrevision":"d47625aac"},{"name":"SkynetHub.io","files":[5408,0],"size":[0.04,0],"link":"https://skynethub.io","chartColor":"#666","version":"1.4.8-master","gitrevision":"ca21c97fc"},{"name":"SiaLoop.net","files":[40979],"size":[0.18],"link":"https://sialoop.net","chartColor":"#666","version":"1.4.7","gitrevision":"000eccb45"},{"name":"SkyDrain.net","files":[42242,914],"size":[0.23,0.04],"link":"https://skydrain.net","chartColor":"#666","version":"1.4.8","gitrevision":"1eb685ba8"},{"name":"Tutemwesi.com","files":[73918],"size":[0.32],"link":"https://skynet.tutemwesi.com","chartColor":"#666","version":"1.4.6-master","gitrevision":"c2a4d83"},{"name":"Luxor.tech","files":[21754],"size":[0.11],"link":"https://skynet.luxor.tech","chartColor":"#666","version":"1.4.5-master","gitrevision":"e1b995f"},{"name":"LightspeedHosting.com","files":[0],"size":[0],"link":"https://vault.lightspeedhosting.com","chartColor":"#666","version":"","gitrevision":""},{"name":"UTXO.no","files":[0],"size":[0],"link":"https://skynet.utxo.no","chartColor":"#666","version":"","gitrevision":""},{"name":"SkyPortal.xyz","files":[22858,0],"size":[0.14,0],"link":"https://skyportal.xyz","chartColor":"#666","version":"1.4.8","gitrevision":"1eb685ba8"}])";
	} else {
		test = response.text;
	}
	for (auto portal : nlohmann::json::parse(text)) {
		result.emplace_back({
			url: portal["link"],
			uploadPath: "/skynet/skyfile",
			fileFieldname: "file",
			directoryFileFieldname: "files[]"
		});
	}
}

skynet::skynet()
: options(default_options())
{ }

skynet::skynet(skynet::portal_options const & options)
: options(options)
{ }

std::string trimSiaPrefix(std::string const & skylink)
{
	if (0 == skylink.compare(0, 6, "sia://")) {
		return skylink.substr(6);
	} else {
		return skylink;
	}
}

std::string trimTrailingSlash(std::string const & url)
{
	if (url[url.size() - 1] == '/') {
		std::string result = url;
		result.resize(result.size() - 1);
		return result;
	} else {
		return url;
	}
}

std::string skynet::upload_file(std::string const & path, std::string filename)
{
	if (!filename.size()) {
		filename = path;
	}

	upload_data data(filename, std::vector<uint8_t>());
	read_file(path, data.data);

	return upload(data);
}

/*
void skynet::upload_directory(std::string const & path, std::string const & filename)
{
	if (!filename.size()) {
		filename = path;
	}
}
*/

std::string skynet::upload(upload_data const & file)
{
	auto url = cpr::Url{trimTrailingSlash(options.url) + trimTrailingSlash(options.uploadPath)};

	return uploadToField({file}, file.filename, url, options.fileFieldname);
}

std::string skynet::upload(std::string const & filename, std::vector<skynet::upload_data> const & files)
{
	auto url = cpr::Url{trimTrailingSlash(options.url) + "/" + trimTrailingSlash(options.uploadPath)};

	return uploadToField(files, filename, url, options.directoryFileFieldname);
}

std::string uploadToField(std::vector<skynet::upload_data> const & files, std::string const & filename, std::string const & url, std::string const & field)
{
	auto parameters = cpr::Parameters{{"filename", filename}};

	cpr::Multipart uploads{};

	for (auto & file : files) {
		uploads.parts.emplace_back(field, cpr::Buffer{file.data.begin(), file.data.end(), file.filename}, file.contenttype);
	}

	auto response = cpr::Post(url, parameters, uploads);
	if (response.error) {
		throw std::runtime_error(response.error.message);
	} else if (response.status_code != 200) {
		throw std::runtime_error(response.text);
	}
	
	auto json = nlohmann::json::parse(response.text);

	std::string skylink = "sia://" + json["skylink"].get<std::string>();

	return skylink;
}

skynet::response skynet::query(std::string const & skylink)
{
	std::string url = trimTrailingSlash(options.url) + "/" + trimSiaPrefix(skylink);

	auto response = cpr::Head(url, cpr::Parameters{{"format","concat"}});
	if (response.error) {
		throw std::runtime_error(response.error.message);
	} else if (response.status_code != 200) {
		throw std::runtime_error("HEAD request failed with status code " + std::to_string(response.status_code));
	}

	skynet::response result;
	result.skylink = skylink;
	result.portal = options;
	result.filename = extractContentDispositionFilename(response.header["content-disposition"]);
	result.metadata = parseCprResponse(response);

	return result;
}

skynet::response skynet::download_file(std::string const & path, std::string const & skylink)
{ 
	response result = download(skylink);
	
	write_file(path, result.data);

	return result;
}

skynet::response skynet::download(std::string const & skylink, std::initializer_list<std::pair<size_t, size_t>> ranges)
{
	skynet::response result;
	std::string url = trimTrailingSlash(options.url) + "/" + trimSiaPrefix(skylink);

	cpr::Header headers;
	if (ranges.size()) {
		std::string header_content;
		bool first = true;
		for (auto range: ranges) {
			result.dataranges.emplace_back(range);
			if (first) {
				header_content += "bytes=";
			} else {
				header_content += ", ";
			}
			header_content += std::to_string(range.first) + "-" + std::to_string(range.first + range.second - 1);
			first = false;
		}
		headers = cpr::Header{{"Range", header_content}};
	}

	auto response = cpr::Get(url, cpr::Parameters{{"format","concat"}}, headers);
	if (response.error) {
		throw std::runtime_error(response.error.message);
	} else if (response.status_code != 200) {
		if (!ranges.size() || response.status_code != 206) {
			throw std::runtime_error(response.text);
		}
	} else if (ranges.size()) {
		throw std::runtime_error("Server does not support partial ranges.");
	}

	result.skylink = skylink;
	result.portal = options;
	result.filename = extractContentDispositionFilename(response.header["content-disposition"]);
	result.metadata = parseCprResponse(response);
	result.data = std::vector<uint8_t>(response.text.begin(), response.text.end());
	if (!ranges.size()) {
		result.dataranges.emplace_back(0, result.metadata.len);
	}

	return result;
}

skynet::response::subfile parse_subfile(size_t & offset, nlohmann::json const & value)
{
	size_t suboffset = offset;

	skynet::response::subfile metadata;
	metadata.contenttype = value["contenttype"].get<std::string>();
	metadata.len = value["len"].get<size_t>();
	metadata.filename = value["filename"].get<std::string>();

	metadata.offset = offset;
	offset += metadata.len;

	if (!value.contains("subfiles")) { return metadata; }

	for (auto & subfile : value["subfiles"].items()) {
		metadata.subfiles.emplace_back(subfile.key(), parse_subfile(suboffset, subfile.value()));
	}

	return metadata;
}

skynet::response::subfile parseCprResponse(cpr::Response & cpr)
{
	auto & raw_json = cpr.header["skynet-file-metadata"];
	auto parsed_json = nlohmann::json::parse(raw_json);
	parsed_json["len"] = std::stoul(cpr.header["content-length"]);
	parsed_json["contenttype"] = cpr.header["content-type"];

	size_t offset = 0;
	return parse_subfile(offset, parsed_json);
}

std::string extractContentDispositionFilename(std::string const & content_disposition)
{
	auto start = content_disposition.find("filename=");
	if (start == std::string::npos) { return {}; }

	start += 9;
	auto first_char = content_disposition[start];
	auto last_char = ';';
	if (first_char == '\'' || first_char == '"') {
		++ start;
		last_char = first_char;
	}
	
	auto end = content_disposition.find(last_char, start);
	if (end == std::string::npos) {
		end = content_disposition.size();
	}

	return { content_disposition.begin() + start, content_disposition.begin() + end };
}

static void read_file(std::string const & path, std::vector<uint8_t> & buffer)
{
	std::ifstream file(path.c_str(), std::ios::in | std::ios::binary | std::ios::ate);

	if (!file.is_open()) { throw std::runtime_error("Failed to open " + path); }

	std::streamsize size = file.tellg();
	file.seekg(0, std::ios::beg);

	buffer.resize(size);
	file.read((char*)buffer.data(), size * sizeof(uint8_t) / sizeof(char));

	if (file.fail()) {
		throw std::runtime_error("Failed to read contents of " + path);
	}
}

static void write_file(std::string const & path, std::vector<uint8_t> const & buffer)
{
	std::ofstream file(path.c_str(), std::ios::out | std::ios::binary);

	if (!file.is_open()) { throw std::runtime_error("Failed to open " + path); }

	file.write((char*)buffer.data(), buffer.size() * sizeof(uint8_t) / sizeof(char));

	if (file.fail()) {
		throw std::runtime_error("Failed to write contents of " + path);
	}
}

bool skynet::portal_stats::operator<(skynet::portal_stats const & other)
{
	// return true if we are first, false if we are not
	auto difference = last_time_used - other.last_time_used;
	if (difference > 60 * 60) {
		return false;
	} else if (difference < -60 * 60) {
		return true;
	}

	return speed > other.speed;
}

}
