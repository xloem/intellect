#include "common.bootstrap"

// let's store state in a common object, a habit workspace treated as the working context

// === Tests ===

// = Runs without throwing an error

// === Behaviors ===

// let's work on Alphas and Betas  Alphas list possible type-parts for an unfinished part of the workspace.  Betas produce parts for the part.
// So, the workspace is made of 'open-ends' linked to behaviors or behavior-specs that can fill those ends in.

// okay, I've run into a problem around the idea of making a concept model for new habits to use.
// I expect the unfinished parts to link to the parts that they
	// rather than implementing classes, which I know would be small and easy, but would give us too many
	// decision-making challenges to complete with any speed, let's write strut code to fill in the gaps.
	// we can make a constructor.

		// if we do want to make classes, they appear to be a good model for everything.
		// they are a concept that executes code as parsed, and the lookup function stores a hierarchical local context
			// so all that would be need would be adding that functionality to 'lookup'
			// and then we could implement it all as parsers, it sounds like
		// yeah, roughly.  then the whole file could be a class

// WHEN INSTANTIATING A NEW HABIT-WORKSPACE, WE'LL NEED TO
	// 1. REPLACE THE HABIT LINK AND ALL ITS REFERENCES WITH REFERENCES TO A NEW CONCEPT
	// 2. REPLACE SELF-REFERENCES WITH REFERENCES TO THE NEW VALUE
concept empty-habit-workspace [
	is habit-workspace

	habit concept empty-habit-workspace-model-habit []

	// a new habit needs a spec, for what needed-information is associated
	unfinished-part concept [
		is habit-interface

		habit empty-habit-workspace-model-habit
		workspace empty-habit-workspace
	]

	// a new habit needs a first step.
	unfinished-part concept [
		is next-step
		last-step empty-habit-workspace-model-habit

		habit empty-habit-workspace-model-habit
		workspace empty-habit-workspace
	]
]
concept habit-interface [
	handler bootstreap-habit-interface-handler
]



concept habit-workspace-agreements [
	introduction habit make-habit-workspace [][][
		// ToDO
	]
	closure habit habit-workspace-unmake [habit-workspace][][
		// TODO
	]
]
concept unfinished-part-agreements [
	introduction habit make-unfinished-part [workspace larger-part type][][
		set result make-concept
		link result 'is' type
		link workspace 'unfinished-part' result
		link result 'workspace' workspace
		link result 'larger-part' larger-part
	]
	closure habit unfinished-part-unmake [unfinished-part][][
		set workspace get unfinished-part 'workspace'
		unlink workspace 'unfinished-part' unfinished-part
		concept-unmake unfinished-part
	]
]

// propose handlers are listed on the type object.

concept next-step [
	handler habit bootstrap-next-step-handler [unfinished-part habit-workspace][][
		// We produce a list of ways to eat the next-step, each of which may produce new unfinished-parts.
		// The new unfinished-parts will need to be tried in subworkspaces that inherit from this one.

			// each way will likely need some agreements, if only for closure to deallocate memory.
	]
]

// next-step is different from conditional-option
// that space is what to condense the problem around, to pick new unfinished-parts that are generated.
//
// next-step: needs to link via a conssitent link, to a new step or a jump
// conditionals: accumulate a link deep inside, to new steps or jumps
// so conditionals probably make conditional-options.
// 
// next-step wcould be conditional.
// conditional is unfinished.  needs steps.
// a primary step for conditional is 'everything'
// it can also have steps named other things.
// it also needs a value to condition on.

// so, although we want to make a compelte conditional, we have
// : unfinished-part: value, for conditional
// : unfinished-part: decision-on-whether-to-have-anything-branch
// : unfinished-part: decision-on-whether-to-have-more-branched
// when these parts are finished, the conditional can be made
// so, unfinished parts have additional contextual closure.
// which describes the whole process as a set of introductions and closures, that close when they open, in a pretty flower.
// and there is value to viewing the process as learning good agreements to make.
// it is fine that some agreements are too big.  the flower is designed to grow from the small ones.

// all behaviors may be introduction-rituals and closure-rituals in a complex set of agreements.
// what's RELEVENT is that closing unfinished-parts provides for the opening of other unfinished-parts to complete
	// initial recursion-depth problem is intended to be handled by always trying options that close early, first.
	// this means we'll need interruptible opening-ceremonies?
		// really, it defines for middle-area after the opening-ceremony.
		// it means the opening continues into the middle.
	// okay, so we need structure to trigger the middle parts, and to conceive of opening continuing through the middle
		// yes.

// CLOSED PATH-PART FOR CORE, COMPLETING. [it's a flower of opening-and-closing-ceremony-triggers, that opens and closes once]
// ^-- right here closes fast.  you don't need to let it trick you into staying open.  use judgement-of-how-long-spent if needed.
// WIP RIGHT HERE.  if confused, what we're doing is making middle-behaviors for the introduction-ceremony of next-steps and
// conditionals.  please save and expand properly.


// = Clone the environment from a habit workspace,
//   and try the habit.

// = Make a habit workspace with spec
//   that matches an existing habit.

// = Build the start of a habit in a workspace.

// = Produce a list of possible habit steps
//   for a workspace.

// = Produce a list of available spaces for a step in
//   a habit workspace

// = Produce a list of combinations between two other
//   lists.


