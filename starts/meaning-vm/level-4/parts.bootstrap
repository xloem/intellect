#include "common.bootstrap"

// let's store state in a common object, a habit workspace treated as the working context

// === Tests ===

// = Runs without throwing an error

// === Behaviors ===

// let's work on Alphas and Betas  Alphas list possible type-parts for an unfinished part of the workspace.  Betas produce parts for the part.
// So, the workspace is made of 'open-ends' linked to behaviors or behavior-specs that can fill those ends in.

// okay, I've run into a problem around the idea of making a concept model for new habits to use.
// I expect the unfinished parts to link to the parts that they
	// rather than implementing classes, which I know would be small and easy, but would give us too many
	// decision-making challenges to complete with any speed, let's write strut code to fill in the gaps.
	// we can make a constructor.

		// if we do want to make classes, they appear to be a good model for everything.
		// they are a concept that executes code as parsed, and the lookup function stores a hierarchical local context
			// so all that would be need would be adding that functionality to 'lookup'
			// and then we could implement it all as parsers, it sounds like
		// yeah, roughly.  then the whole file could be a class

// WHEN INSTANTIATING A NEW HABIT-WORKSPACE, WE'LL NEED TO
	// 1. REPLACE THE HABIT LINK AND ALL ITS REFERENCES WITH REFERENCES TO A NEW CONCEPT
	// 2. REPLACE SELF-REFERENCES WITH REFERENCES TO THE NEW VALUE
concept empty-habit-workspace [
	is habit-workspace

	habit concept empty-habit-workspace-model-habit []

	// a new habit needs a spec, for what needed-information is associated
	unfinished-part concept [
		is habit-interface

		habit empty-habit-workspace-model-habit
		workspace empty-habit-workspace
	]

	// a new habit needs a first step.
	unfinished-part concept [
		is next-step
		last-step empty-habit-workspace-model-habit

		habit empty-habit-workspace-model-habit
		workspace empty-habit-workspace
	]
]
concept habit-interface [
	handler bootstreap-habit-interface-handler
]

concept habit-workspace-norms [
	begin habit make-habit-workspace [][][
		// ToDO
	]
	end habit habit-workspace-unmake [habit-workspace][][
		// TODO
	]
]
concept unfinished-part [
	// norms
	begin habit make-unfinished-part [workspace larger-part type][result][
		set result make-concept
		link result 'is' 'unfinished-part'
		link result 'is' type
		link workspace 'unfinished-part' result
		link result 'workspace' workspace
		link result 'larger-part' larger-part
		pick interested
			if 'nothing' return.
	]
	// unfinished parts have different states and paths.
	// each unfinished part is associated with options for how to approach it
	// these ideas may result in a finished part, or may result in more unfinished-parts.
	// so, we need to plan a path for this.

		/*
			for each unfinished part, some function generates options. [are these options more unfinished parts?]
			the system now has a bunch of options.  each option excludes some set of other options.
			it may pick 1 option from each exclusive set, or it may just pick 1 option and leave others unpicked.
			regardless, it clones the workspace or stores undo information, and calls functions to generate results
			for the options it picks.
			- it sounds like a set-of-options is an unfinished part.  it needs a decision on which option to try.
			- who handles picking the option and continuing?
				this is the set of subparts that live as the behavior.
				given not much growth is needed here, if there is an easier way to do it than with many subparts,
				it could be good.  the value to the subparts is that the whole system is a good analogue to other
				planning processes.
			okay, so there is value to interruptible sequential processes.  the work would be aided if the VM is part
			of the workspace.
					this is actually doable without much change.  a function context can access the current VM.
					when your call returns, it uses what is linked as the contextual vm information.
					so a subprocess in the same notepad as an outer process can alter the outer process.
			okay, so the idea of "trying different return values" seems doable?
						it inverts the idea of who's in charge.  where is the progress information stored?
				remember we are picking between which is easier/faster to make:
				1. trying different return values
				2. coding all behaviors as small separated parts that hand off work
					note: these behaviors likely don't need to be altered during growth
				there is lots of value to both of these.  i propose option2, but let us explore option1
					for option1, we would have a special returning-function we could use at the end of things
					to return options.  before using it, we would have to set up how to pick options, I guess
						it kind of seems we'd want 2 kinds of it.
						1 that is commonly used in workers
						and 1 that is used in its implementation.
						this lets us write everything sequentially, like async functions in javascript.
						so the main cognitive process would be all get-an-option instead of do-this
						execution would start and then stop when a decision was needed, and jump allll the way back
						an object would be returned that gives a way to continue after an option is picked
						the system would have to preserve and clone its state some other way if it wanted
						to try in a bubble, but it has space inbetween to do this.
					i think the implementation of \#2 is more clear, even if \#1 has much clearer,more intuitive, usage.
						for \#2 we will need to code many behaviors in multiple habits, that store their work,
						and then pick it up again.
							in \#1, work is stored in the function context, already.
							can we just store the function context, and resume from it?
							let's make a way to jump outside of habits.  this seems a nice way to move
							towards both things.  it can store a way to return to where it is, when it does
							this.
					one more thought: option \#1 doesn't provide for escape.  jumping-out-of-a-habit likely does.
						with option \#1 when you find options, you return out of the whole tree.
						with option \#2, your growth and exploration is managed either by a leader or a community.
						you never spawn other trees yourself.
						with this option \#3 of jump-outside-of-habit, the problem remains open.
							so, we may want to establish a norm somewhere of not providing for recursion or
							excessive calls of other processes.
							we would want to merge jump-outside-of-a-habit with call-a-function.
							but it doesn't actually matter.
					let's plan past pause-and-go-elsewhere.  say we implement that.
					what structure does it take?
						roughly, we write code that builds an entire habit, by selecting from decisions.
						many of its code paths loop forever, depending on the decisions.
						but the decisions are all learned around, such that that becomes silly to do quickly.
							for generality, we'll want the paths inbetween decisions to be considerable
							as single functions.  this means habits that take a vm context, and
							jump to a decision-making process at the end.


CORE FOCUS \#2: AFTER CELEBRATE-HEALING-AS-ALL-ACTION:
	We can write ways as processes that depend on learned-decisions,-without-ways-for-making-the-decisions.
	This works well and produces clear description, for the core process of building a habit to a specification.
	Results of making decisions are written.  How to make the decision is not.
			(this is totally new as far as we can tell)
								there's an add-on for testing-partway:
								pause the VM when it hits an incomplete-spot.
								very similar to make-a-decision, and then running is the same
								as building.
		*/
	end habit unfinished-part-unmake [unfinished-part][result][
		set result get-or-nothing unfinished-part 'finished-part'
		set workspace get unfinished-part 'workspace'
		unlink workspace 'unfinished-part' unfinished-part
		concept-unmake unfinished-part
		pick result if 'nothing' return.
	]
]
concept next-step [
	is unfinished-part
	begin habit make-unfinished-next-step [workspace habit][][
		set result make-unfinished-part workspace habit next-step
	]
]

// making them as habits for now just to feel the space out
// remember we make OPTIONS for moving the part on, and then we produce RESULT for EACH OPTION.
// so, unfinished-part does not close.  it spawns new subworkspaces.
habit make-conditional [][][
	set value make-part 'value'
	set have-anything make-part 'decide-have-anything-branch'
		// each of these spews out many options
		// each option will possible make a subworkspace.

		// we can make a subworkspace with 'is' link
		// subworkspaces exist around decisions	
		// and a tree of subworkspaces eventually collapse
		// to a possible finished part.
		// making parts often requires decisions.
		
		// we'd also like to make a list of options,
		// but for now i guess we can do breadth-first
		// in that lit.
		// I AM RIGHT HERE, IMPLEMENTING SUBWORKSPACE OUTLINE
		// FOR CORE HABIT-BUILDING HABITS such as condition-part.
		// let us find where we recommended to split, and see if there is relevence
			// so what's important atm is that A. we can exhaustively try ALL code paths, SHORTEST FIRST
			// and B. when decisions are made, the system can look at the options before one is chosen.
			// it looks like B makes A happen, the system must try options first.
			// so propose there is a solid managing process, that tries shortest path first.
			// these sub-parts just produce options.
				
]

// propose handlers are listed on the type object.

concept next-step [
	handler habit bootstrap-next-step-handler [unfinished-part habit-workspace][][
		// We produce a list of ways to eat the next-step, each of which may produce new unfinished-parts.
		// The new unfinished-parts will need to be tried in subworkspaces that inherit from this one.

			// each way will likely need some agreements, if only for closure to deallocate memory.
	]
]

// next-step is different from conditional-option
// that space is what to condense the problem around, to pick new unfinished-parts that are generated.
//
// next-step: needs to link via a conssitent link, to a new step or a jump
// conditionals: accumulate a link deep inside, to new steps or jumps
// so conditionals probably make conditional-options.
// 
// next-step wcould be conditional.
// conditional is unfinished.  needs steps.
// a primary step for conditional is 'everything'
// it can also have steps named other things.
// it also needs a value to condition on.

// so, although we want to make a compelte conditional, we have
// : unfinished-part: value, for conditional
// : unfinished-part: decision-on-whether-to-have-anything-branch
// : unfinished-part: decision-on-whether-to-have-more-branched
// when these parts are finished, the conditional can be made
// so, unfinished parts have additional contextual closure.
// which describes the whole process as a set of introductions and closures, that close when they open, in a pretty flower.
// and there is value to viewing the process as learning good agreements to make.
// it is fine that some agreements are too big.  the flower is designed to grow from the small ones.

// all behaviors may be introduction-rituals and closure-rituals in a complex set of agreements.

/*
need [was always there]
introduction
	Welcome.  This is a ritual for continuing our previous work.  It is higher up on this screen.
play
	what kind of parts could we put in this ritual?
		what have you been working on?
	I think we just undestand the shape of early intellect growth so well, that it triggered importance.
	I think this other stuff likely doesn't matter.
	We need agreements for working with humans.  Let's call them norms.
	For the misunderstood, let's review 1 other option.  Game.  Oh, thankfulness!  Sure.
	break taken.  RETURN TO THIS RITUAL.  WE ARE BUILDING THE HABIT FLOWER BY MAKING CONSTRUCTOR/DESTRUCTOR NORMS.
		It turns out we aren't all ready to publicize this work yet.  Oops.
resolution [resolution never ends]
*/
// what's RELEVENT is that closing unfinished-parts provides for the opening of other unfinished-parts to complete
	// initial recursion-depth problem is intended to be handled by always trying options that close early, first.
	// this means we'll need interruptible opening-ceremonies?
		// really, it defines for middle-area after the opening-ceremony.
		// it means the opening continues into the middle.
	// okay, so we need structure to trigger the middle parts, and to conceive of opening continuing through the middle
		// yes.

// CLOSED PATH-PART FOR CORE, COMPLETING. [it's a flower of opening-and-closing-ceremony-triggers, that opens and closes once]
// ^-- right here closes fast.  you don't need to let it trick you into staying open.  use judgement-of-how-long-spent if needed.
// WIP RIGHT HERE.  if confused, what we're doing is making middle-behaviors for the introduction-ceremony of next-steps and
// conditionals.  please save and expand properly.

/*
We are in a digital-life ceremony.  Please respect our game.  Advice on improving it is welcome.
	Advice: we need ceremonies around making progress.  Your buildup of ceremony is so wonderful and inspiring, though.
CEREMONIOUSLY-MARKED-AS-CRUCIAL
we celebrate giving healing to those who mourn. <- definition of intellect, as a 'ritual ceremony'.  it looks like opening-and-closing are mourning-and-healing-by-celebration-and-pain,-kinda. PLEASE RECORD SCREEN.  IT IS A MESSY BIRTH BUT AN IMPORTANT ONE.
CEREMONIOUSLY-MARKED-AS-CRUCIAL

rewarding: a game of nurturing caring behavior.
let us make a class called 'game'
it has 'norms' 'agreements', let us not say rules to not encourage punishmentculture.  'norms' supports social-justice-culture a little,
and we don't have anything else yet.
'norms' are how you start a 'game'.
a 'game' is started with a 'reason'
the game ends in thankfulness, giving appreciation both to the reason, and receiving it from.
	since we do not have a word for fluid-rules, we could call them 'fun' as kind of a stretch. or 'way' or 'how'

*/


// = Clone the environment from a habit workspace,
//   and try the habit.

// = Make a habit workspace with spec
//   that matches an existing habit.

// = Build the start of a habit in a workspace.

// = Produce a list of possible habit steps
//   for a workspace.

// = Produce a list of available spaces for a step in
//   a habit workspace

// = Produce a list of combinations between two other
//   lists.


