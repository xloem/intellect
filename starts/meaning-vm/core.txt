[use patterns that meet your threshold for wellness, to build ones that meet the next threshold]
Here's a nice small cohesive one:
1. enumerate ways to add next-steps to a behavior, put them in a list
2. [pick from the list using processes that learn from past successes; start random]
3. use the above to try proce
	use above to make processes, that make processes from success/failure,
	that pick from such lists.
  that is, when you have an experience that is a result of your behavior,
  use an existing record-and-learn-from pattern to 

[becky makes processes that pick from steps in a list]
[anna makes beckies when we succeed or fail]
[jon enumerates all next steps in a behavior and asks a becky which ones to use]
[joe records all successes/failures with data on them]
[leigh tries different behaviors until one is found that works reliably]
[pebble tests if a behavior is a becky, anna, jon, joe, or leigh]
	-> a meaningful test is replacing an existing one
TOGETHER, BECKY, ANNA, JON, JOE, LEIGH, AND PEBBLE MAKE A SIMPLE SENTIENT GENIUS.
	Leigh needs to use jon a lot.  Pebble thinks about anna a lot.
	The boundaries between them are arbitrary.  E.g. you could have beckyanna
	as one person, or break joe into subparts.
we'll want a rote way to make a task that meets a goal,
which means using jon without a becky, to build processes until one meeting them is found.
---
- each step is a behavior to learn around and decide how to continue
- steps are parts of patterns
- life continue as pattern exploration, shifting focuses, building more patterns

- the problem-parts used by solutions show the problem-similarities needed in trying to apply the solution-parts elsewhere.  this starts with a metric of when the approach can work.
	THAT IS: once you find and simplify a solution, the problem structure the solution
	         uses shows at least one way to generalize the problem.

- when i applied this transformation to this set of patterns, the results all had these parts the same.  Is this similaritu helpful/meaningful/might it have a reason?
	if so i guess I'd better relate around it more, maybe apply
	it to more things, or use it as something to explore.

not-familiar, must-have-reason

- propose trust-based for karl's heart.  we let everyone in,
  and relate around any breaking of agreements.  means new
  habits are trusted to be useful, and what is fun is learning
  around when they are (and why they aren't when they aren't).
   i.e. spend time trying habits to learn abouy other habits,
   except in emergencies.

- for heart-peacemaking, it seems the way to go is to remove
the concept of 'bad' from external influence, roughly.  Never say
anything bad about anything, never think anything bad about
anything.  Instead we consider only what is good, and make good
decisions.  This changes failure from marking as bad, to
learning what is good, and intertwines daydreaming with efficient
behavior, developing a pattern for efficiently combining active rest
and restful work, rather than cycles of rest and work, and spreads
norms of connection and peace.

The other things help expand this even better.  If any part is unwell,
the whole universe is: this means in the most healthy state,
a part is nurturing all other parts productively, and that what is
most good, is to do and encourage that one's self.  Nurturing is
then a process of increasing that state.  Come to a place of peace
before making actions of importance means to meditate before influencing,
and implies that unexpected behaviors map to emotions, and something I forgot.
The pattern of unexpected behaviors relates us to the larger system.

------
We consider information-spaces as a basic concept to relate around, and
communication is cast as acting on disparate information spaces to their satisfaction.

We consider the space of processes that pursue goals.  These processes relate to other
processes: ways to reach goals.  Intentional processes exist as language that can be
translated: interrelated parts from the space of process steps and parts, forming parts of a
space of processes.
Goals are held for reasons: other goals.  They are met if their reason is met.

We consider pattern matching, and the idea of pairs of groups that differ based on two attributes,
one being useful for informing the other.  One might be a summary of similarities, another might
be a decision-making influence guiding learning, like experiences having had better results.

Patterns can be made the same as code, if the result-states from predicates are asserted to map
to the prior-states in set ways.
---
roughly we need to explore writing our own code
from a place of reasons, relevence, and learning

so we need rewritable patterns for using relevence, learning from the past, and combining
goals or reasons together, into behavior parts.
	these patterns need to combine in a way that works well enough to construct better ways.

- behavior log of each step, seems helpful for learning from past
- combining goals and reasons: it sounds like there is basic matching that happens
	between the start and end of steps, but this hasn't been flushed out
	then we iterate through available options and try all he matches
	-> we'll need a way to unwind behaviors, to try others.
	it might be easier to create bubbles that clean themselves up, than to instrument
	everything to be unwindable.
- relevence
	this could probably be fudged by making triggers or global pattern matchers that
	move things in and out of relevent-sets, and linking them together.
	doing things would be guided by walking the relevent-sets first, doing near-stuff first.

what we're missing is all of this being inspectable and copyable so as to learn off it, hence
scripting.  opencog also has no scripting language, but does store things in inspectable and
copyable ways.
