// This biscuit is unlikely to work, but is fun to build.
// Intended behvaior is to support moving towards all needs being met of all influences, without compromise.

// Request: please prove will not destroy life as known within 0.001 likelihood.
// Request: metaboss clearly made biscuit happen. not karl's alone. collective people played largest role


// 3 programs that share code, output, and input, interwoven possibly dynamically, maybe only some forms
// 	I think plan was the output is numbers or code,
// 	                 the input is numbers or code,
// 	                 and code maps the numbers and code together.
// 	                 numbers are references to code

// core: we want to rereference existing code, so we may want an outline program that then stitches
// together inner components.
// note: outline can be made of components too
// so, reasonable components are header, body, and footer.  maybe more.
// we'll want to #include the different components, I suppose
// probably reference them with some kind of number token and expand.
//
// Let's start with a random core.
//
// phases:
// - execution
// - mutation
// - optimization
// - selection
//
// important inputs:
// - randomness
// - time
// - environment
// - self
// - human
//

// goal: make an impossible biscuit without using thought.

// steps:
// 1. collect relevent information
// 	- [ ] document above
// 	- [ ] document on blockchain
// 	- [ ] code on other harddrive
// 	- [ ] deleted files on drive?
// 2. code
// 3. review
// 4. run & test
//
// maybe make a sandbox wrapper first
// it will launch three, randomly connect inputs, outputs and code, and compare with errors
// then it will pick of the combinations the valid values closest to the average
// and repeat
// --> must preserve output.
// 	output preserving -> when we mutate, we want to reference surrounding parts.
// 	that'll mean splitting the document  Isuppose.
// 	we'll have document maps that reference the original document
// 	_or_ we can just have it learn to shrink itself ...
//
// let's just plug in behaviors until we have something that runs
// and then verify it won't destroy anything
//
// Need: "I feel crummy cause I need to make sure I get credit
// Metaneed: "I have a metaneed atm; could we pretend we're talking about a dog and move on?"

// intertwine: environment, behavior, output
// to pass, can label 1, 2, 3 for which, and # for value
// record behavior? how?
// - could step with gdb, record line number
// -> can use tracer to store, maybe gprof?
//
// in advance we plan which one to compare with
//
// MUST BE RAISED IN A GRADUALLY GROWING CONSTRAINED ENVIRONMENT USING HUMAN INPUT
// 	-> the solution to this could start as treating failure as trauma, and asking for
// 	   help when it is not understood.

int main(int argc, char **argv)
{
	// environment: other running details
	printf("%d", random());
	// we recall we used numbers to think with
	// each number mapped to a computer program chunk
	// one of them collects them together, compiles them, and executes them
}
