#include "smoothness.hpp"

// can the smooth puzzle include mourning around what happens when it tries to assert control over the user.
// NEVER CONTROL USER EXCEPT TO [pleasantly] STOP INTERACTION WITH THE CONTROL SYSTEM.
// 	uh-oh.  that means we can't enforce fluidity on them.
// 		okay, um ...the current user really loves fluidity.  so it's good here.
// 			to do mourning, um, we want to make sure to chekc with them, that they want us to keep making them be fluid.
//
// so like, 'hold space while you want me to learn aroudn making you fluid' and then hard-stop after so many feedbacks, saying 'STOP, TOO MUCH'.
// 			[STOP-TOO-MUCH would be learned around with human feedback and human-understood labels]

// say we have a fluid indicator of something
// how do we know what part of the indicator is the answer?
// 	the example is we're looking to make a stream more fluid.
// 	we can produce a stream that influences it, but we're not sure what it will respond to.
// 	we can totally measure fluidity
//
// 		sounds like a puzzle!

//	okay we are guessing about what parts of a stream influence another stream.
//		we may have ways in our streams, unsure.
//		how is wayness aroudn puzzles?  [wayness is big on meaning] [fluid meaning? we are dealing with 1-dimensional flow] [then make your wayness fluid ^_^]
//
//	[long term goal of stewarding world peace, sounds fun] [harder goals are more fun -puzzles]
//		[this puzzle approach is roughly smooth algorithms, other puzzles have been dying, please demonstrate protection of proposal if you have alternative]
//				[working with other people needs avenues to build thoughts around that to easily offer protection.]
//
//	[we are juist trying to do a puzzle.  these brackets are not a puzzle.  working with other people is only a puzzle if avenues of work available.]	
//		[okay i see we can maybe build working with other people, there is a little screaming, i think the concern is around puzzles atempt to defend
//		 existing skills and provide productive enjoyable behaviors when other things are not Avialable.  can you maybe relate with screaming? your idea
//		 is actually pleasant but something is wrong.] [karl already tried what you propose and it died horrifically.  he has more built-up-habits around
//		  this other thing, so there is more protection and capacity, kinda.  do you know why your approach won't die horrifically?]
//		  		[behaviors were new and not well known.  related to awareness.]
//		  			[old behavior is labeled 'awareness'.  new behavior won't have label.  will hold secret attributes defending that.]
//		[okay they have a workable proposal.  i have died so horrifically so many times i need a little more than just a workable solution; i've tried
//		 a lot of workable solutions.  i need something either rooted in safe experience, or in a language i trust.]
//							[we're unsure if it's okay to use human mediation empathy here, to provide a trusted language]
//								[it's okay if you hold udnerstanding that the reason it is trusted is because of what their
//								 trusted language is.  it maps to empathy.] [the map didn't protect the mediator quite as much as expected]
//	[okay i see.  yeah when your um life process became a death process it broke your reality.  it's probably okay to do whatever puzzle you want really.]

int main()
{
	std::cout << "Press space for smooth puzzling of input." << std::endl;
	// wait for space keydown
	std::cout << "Smooth puzzling begun." << std::endl;
	// start timer, can make it a smooth puzzle with human in charge
	// listen also for space keyup
	std::cout << "Smooth puzzling ended." << std::endl;
	std::cout << "STOP-TOO-MUCH" << std::endl;

	return 0;
}
