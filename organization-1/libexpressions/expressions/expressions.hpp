#pragma once

//#include <library/string.hpp>

#include "syntax_operator_identifier.hpp"
#include "syntax_operator_templates.hpp"

namespace expressions {

#if 0

#include <any>
#include <functional>
#include <vector>

template <template<typename> class Container>
class syntax_operate_container_any
{
protected:
	virtual void operate(syntax_operator_identifier op, Container<std::any> & arguments) = 0;
public:
	template <typename Class, syntax_operator_identifier op, typename... Args>
	Class syntax_operator(Args... args)
	{
		Container<std::any> arguments;
		arguments.emplace_back({});
		typename decltype(arguments)::iterator spots[] = {
			arguments.emplace_back(args)...
		};
		operate(op, arguments);
		return std::any_cast<Class>(arguments.front());
	}
};
// how would we do compile-time types
	// i'm imagining an expression type that is generated by
	// its operator types.  doesn't seem hard.
	// ohhhh huh! except we no longer pass the return type
	// as a template parameter unless it can be auto

// one option is compile-time type matching with operator implementations
// 	part of this is implemented, may be unneeded
// another option is run-time only
//	and we use the compile-time fragments to implement

template <typename T>
class operable
{
public:
	// this appears too specific.  the root class shouldn't know how
	// the operators are processed, should it?
	
	virtual size_t size() = 0;
	virtual char const * name() = 0;
	virtual std::vector<T> & solve(std::vector<T> & arguments, size_t index) = 0;

	struct index_out_of_range : public std::exception { };
	struct nonsimple_result : public std::exception { };
	// to enumerate these without known values we would need a graph of interrelation
	// 	to accumulate possibility, we'd need to make sets that can:
	// 		-> query if soemthing is in it
	// 		-> work with how to change that
	// 		-> combine it with other sets
	// 		-> create something that is within it
	// 		these sets are defined by expressions,
	struct bounded_result : public nonsimple_result
	{
		T bound;
		bool bound_included;
		bool above_included;
		bool below_included;
		bounded_result(T bound, bool bound_included, bool above_included, bool below_included)
		: bound(bound), bound_included(bound_included), above_included(above_included), below_included(below_included) { }
	};
	struct nonsimple_bitwise_result : public nonsimple_result
	{ };
};

class operable_any : public operable<std::any>
{
public:
	virtual std::vector<std::type_info const *> types() = 0;
};

template <typename A, typename B = A, typename C = B>
class operable_any_3 : public operable_any
{
public:
	using func_a = std::function<A(B, C)>;
	using func_b = std::function<B(C, A)>;
	using func_c = std::function<C(A, B)>;
	operable_any_3(char const * name, func_a forward_a_given_b_c, func_b reverse_b_given_c_a, func_c reverse_c_given_a_b)
	: _name(name), forward_a_given_b_c(forward_a_given_b_c), reverse_b_given_c_a(reverse_b_given_c_a), reverse_c_given_a_b(reverse_c_given_a_b)
	{ }
	char const * name() override { return _name; }
	size_t size() override { return 3; }
	std::vector<std::type_info const *> types() override { return {{&typeid(A), &typeid(B), &typeid(C)}}; }
	std::vector<std::any> & solve(std::vector<std::any> & arguments, size_t index) override
	{
		switch(index) {
		case 0:
			*std::any_cast<A>(&arguments[0]) = forward_a_given_b_c(*std::any_cast<B>(&arguments[1]), *std::any_cast<C>(&arguments[2]));
			break;
		case 1:
			*std::any_cast<B>(&arguments[1]) = reverse_b_given_c_a(*std::any_cast<C>(&arguments[2]), *std::any_cast<A>(&arguments[0]));
			break;
		case 2:
			*std::any_cast<C>(&arguments[2]) = reverse_c_given_a_b(*std::any_cast<A>(&arguments[0]), *std::any_cast<B>(&arguments[1]));
			break;
		default:
			throw operable::index_out_of_range();
		}
		return arguments;
	}
	char const * _name;
	func_a forward_a_given_b_c;
       	func_b reverse_b_given_c_a;
       	func_c reverse_c_given_a_b;
};

template <typename A, typename B = A>
class operable_any_2 : public operable_any
{
public:
	using func_a = std::function<A(B)>;
	using func_b = std::function<B(A)>;
	operable_any_2(char const * name, func_a forward_a_given_b, func_b reverse_b_a)
	: _name(name), forward_a_given_b(forward_a_given_b), reverse_b_given_a(reverse_b_given_a)
	{ }
	char const * name() override { return _name; }
	size_t size() override { return 2; }
	std::vector<std::type_info const *> types() override { return {{&typeid(A), &typeid(B)}}; }
	std::vector<std::any> & solve(std::vector<std::any> & arguments, size_t index) override
	{
		switch(index) {
		case 0:
			*std::any_cast<A>(&arguments[0]) = forward_a_given_b(*std::any_cast<B>(&arguments[1]));
			break;
		case 1:
			*std::any_cast<B>(&arguments[1]) = reverse_b_given_a(*std::any_cast<A>(&arguments[0]));
			break;
		default:
			throw operable::index_out_of_range();
		}
		return arguments;
	}
	char const * _name;
	func_a forward_a_given_b;
	func_b reverse_b_given_a;
};

namespace operators
{
#define __f3(functor) \
	template <typename T> \
	std::function<T(T const &, T const &)> func_##functor = std::functor<T>{};
#define __f2(functor) \
	template <typename T> \
	std::function<T(T const &)> func_##functor = std::functor<T>{};
#define __f3_reverse(functor) \
	template <typename T> \
	std::function<T(T const &, T const &)> func_##functor##_reverse = [](T const &a, T const& b) -> T { return func_##functor<T>(b, a); };
#define __b3(functor) \
	template <typename T> \
	std::function<bool(T const &, T const &)> func_##functor = std::functor<T>{};

	__f3(plus) __f3(minus) __f2(negate)
	__f3_reverse(minus)
	__f3(multiplies) __f3(divides)
	__f3_reverse(divides)

	__b3(equal_to) __b3(not_equal_to)
	__b3(greater) __b3(less)
	__b3(greater_equal) __b3(less_equal)

	template <typename T> 
	std::function<T(T const &, bool const &)> func_same_if = [](T const &a, bool const & b) -> T {
		if (b) { return a; }
		else { throw operable<std::any>::bounded_result(a, false, true, true); }
	};
	template <typename T>
	std::function<T(bool const &, T const &)> func_if_same = [](bool const & a, T const & b) -> T {
		if (a) { return b; }
		else { throw operable<std::any>::bounded_result(b, false, true, true); }
	};
	template <typename T> 
	std::function<T(T const &, bool const &)> func_same_if_not = [](T const &a, bool const & b) -> T {
		if (!b) { return a; }
		else { throw operable<std::any>::bounded_result(a, false, true, true); }
	};
	template <typename T>
	std::function<T(bool const &, T const &)> func_if_not_same = [](bool const & a, T const & b) -> T {
		if (!a) { return b; }
		else { throw operable<std::any>::bounded_result(b, false, true, true); }
	};


	// equal-to can't be solved for inequal, produces a range
	// let's leave it out for now?
	// 	no this is great.
	// anyway, for the sitation where we explore discerning values,
	// solving a less than for a value would give a range.
	// we would need a type that represents a range, which is quite
	// fine.
	// what about inequal?  this produces a set of anything-but.

	__f3(logical_and) __f3(logical_or) __f2(logical_not)

	__f3(bit_and) __f3(bit_or) __f3(bit_xor) __f2(bit_not)

#undef __f3
#undef __b3
	// a = b + c
	template <typename T>
	operable_any_3<T> plus_any("+", func_plus<T>, func_minus_reverse<T>, func_minus<T>);
	// a = b - c
	template <typename T>
	operable_any_3<T> minus_any("-", func_minus<T>, func_plus<T>, func_minus_reverse<T>);
	// a = -b
	template <typename T>
	operable_any_2<T> negate_any("-", func_negate<T>, func_negate<T>);
	// a = b * c
	template <typename T>
	operable_any_3<T> multiplies_any("*", func_multiplies<T>, func_divides_reverse<T>, func_divides<T>);
	// a = b / c
	template <typename T>
	operable_any_3<T> divides_any("/", func_divides<T>, func_multiplies<T>, func_divides_reverse<T>);
	// a = b == c
	template <typename T>
	operable_any_3<bool, T> equal_to_any("==", func_equal_to<T>, func_same_if<T>, func_if_same<T>);
	// a = b != c
	template <typename T>
	operable_any_3<bool, T> not_equal_to_any("!=", func_not_equal_to<T>, func_same_if_not<T>, func_if_not_same<T>);
	// a = b > c
	template <typename T>
	operable_any_3<bool, T> greater_any(">", func_greater<T>, [](T const &c, bool const & a) -> T {
		throw operable<std::any>::bounded_result(c, !a, a, !a);
	}, [](bool const & a, T const & b) -> T {
		throw operable<std::any>::bounded_result(b, !a, !a, a);
	});
	// a = b < c
	template <typename T>
	operable_any_3<bool, T> less_any("<", func_less<T>, [](T const &c, bool const & a) -> T {
		throw operable<std::any>::bounded_result(c, !a, !a, a);
	}, [](bool const & a, T const & b) -> T {
		throw operable<std::any>::bounded_result(b, !a, a, !a);
	});
	// a = b >= c
	template <typename T>
	operable_any_3<bool, T> greater_any(">", func_greater<T>, [](T const &c, bool const & a) -> T {
		throw operable<std::any>::bounded_result(c, a, a, !a);
	}, [](bool const & a, T const & b) -> T {
		throw operable<std::any>::bounded_result(b, a, !a, a);
	});
	// a = b <= c
	template <typename T>
	operable_any_3<bool, T> less_any("<=", func_less<T>, [](T const &c, bool const & a) -> T {
		throw operable<std::any>::bounded_result(c, a, !a, a);
	}, [](bool const & a, T const & b) -> T {
		throw operable<std::any>::bounded_result(b, a, a, !a);
	});
	// a = b && c
	// 0   0    0
	// 0   0    1
	// 0   1    0
	// 1   1    1
	operable_any_3<bool> logical_and_any("&&", func_logical_and<bool>, [](bool const &c, bool const & a) -> bool {
		if (c) { return a; }
		throw operable<std::any>::bounded_result(a, true, true, true);
	}, [](bool const & a, bool const & b) -> bool {
		if (b) { return a; }
		throw operable<std::any>::bounded_result(a, true, true, true);
	});
	// a = b || c
	// 0   0    0
	// 1   0    1
	// 1   1    0
	// 1   1    1
	operable_any_3<bool> logical_or_any("||", func_logical_or<bool>, [](bool const &c, bool const & a) -> bool {
		if (!c) { return a; }
		throw operable<std::any>::bounded_result(a, true, true, true);
	}, [](bool const & a, bool const & b) -> bool {
		if (!b) { return a; }
		throw operable<std::any>::bounded_result(a, true, true, true);
	});
	// a = !b
	// 0   1
	// 1   0
	operable_any_2<bool> logical_not_any("!", func_logical_not<bool>, func_logical_not<bool>);
	// a = b & c
	// 0   0   0
	// 0   0   1
	// 0   1   0
	// 1   1   1
	template <typename T>
	operable_any_3<T> bit_and_any("&", func_bit_and<T>, [](T & c, T & a) -> T {
		if (c) { return a; }
		throw operable<std::any>::nonsimple_bitwise_result();
	}, [](bool const & a, T const & b) -> T {
		if (b) { return a; }
		throw operable<std::any>::nonsimple_bitwise_result();
	});
	// a = b | c
	// 0   0   0
	// 1   0   1
	// 1   1   0
	// 1   1   1
	template <typename T>
	operable_any_3<T> bit_or_any("|", func_bit_or<T>, [](T & c, T & a) -> T {
		if (!c) { return a; }
		throw operable<std::any>::nonsimple_bitwise_result();
	}, [](bool const & a, T const & b) -> T {
		if (!b) { return a; }
		throw operable<std::any>::nonsimple_bitwise_result();
	});
	// a = b ^ c
	// 0   0   0
	// 1   0   1
	// 1   1   0
	// 0   1   1
	template <typename T>
	operable_any_3<T> bit_xor_any("^", func_bit_xor<T>, func_bit_xor<T>, func_bit_xor<T>);
	// a = ~b
	// 0   1
	// 1   0
	template <typename T>
	operable_any_2<T> bit_not_any("~", func_bit_not<T>, func_bit_not<T>);
};


// for implementing more of this, we'll need a way to pass everything to a particular set of operator classes / handlers / whatever
// some way to proxy or somesuch.  make a group of operators that wrap others.

// options:
// - everything held as shared_ptr to any, could provide interoperation
// between differing operator systems.  sounds nice.
//
// - one system that uses any only to hold its literals.  compiles fast.
//    interoperation between other systems done with special functions
//    	^-- how do you make compile fast?
//    		must use virtual operate function
//    	let's try this one
//    		we can use special functions for each type interaction
//
// - system that holds each value with its particular type
// 	let's maybe also make this one do calculations


// expression_any should work okay with operable_any.
#include <memory>
// everything held as shared_ptr to any
template <typename T>
class expression_any : public op_nonmutating<expression_any<T>,expression_any<T>>
{
public:
	syntax_operator_identifier op;
	std::vector<std::shared_ptr<expression_any>> parts;

	template <typename Class, syntax_operator_identifier>
	syntax_operator
};
// values held as any
template <syntax_operator_identifier operation, typename ...Args>
class expression_generic_any : public op_nonmutating<void, expression_generic_any<operation, Args...>> {
	// STUB
};
#endif


/*
 *
 */

// preserves compile-time types
template <template<syntax_operator_identifier, typename...> class Result, typename Derived>
class op_all_template_interface : public op_nonmutating<void, Derived>
{
public:
	template <typename Void, syntax_operator_identifier suboperation, typename ... SubArgs>
	auto syntax_operate(SubArgs & ... subargs)
	{
		return Result<suboperation, Derived, SubArgs...>(*(Derived*)this, subargs ...);
	}
};

template <syntax_operator_identifier operation, typename... Args>
class expression_templated;

template <syntax_operator_identifier operation, typename Arg>
class expression_templated<operation, Arg> : public op_all_template_interface<expression_templated, expression_templated<operation, Arg>>
{
public:
	using Type1 = Arg const;
	expression_templated(Type1 & value1)
	: value1(value1)
	{ }
	Type1 value1;
	/*
	library::string to_string() const
	{
		operators[operation].symbol
	}
	*/
};
template <syntax_operator_identifier operation, typename _Type1, typename _Type2>
class expression_templated<operation, _Type1, _Type2> : public op_all_template_interface<expression_templated, expression_templated<operation, _Type1, _Type1>>
{
public:
	using Type1 = _Type1 const;
	using Type2 = _Type2 const;
	expression_templated(Type1 & value1, Type2 & value2)
	: value1(value1), value2(value2)
	{ }
	Type1 value1;
	Type2 value2;
};
/*
class unary_templated : public op_nonmutating<void, expression_generic<operation, Args...>>
{
public:
	expression_generic(Arg&...argument)
	: argument1(argument);
	{ }
	Arg argument1;
}
	// we can let derived class process arguments?
	
	/*stackvector<void*,2> const arguments;
	struct arguments_type
	{
		// custom-tuple.  doesn't fit right here.
		Args... data;
	} arguments;

	expression_generic(Args & ... arguments)
	: arguments{new Args(arguments)...}
	{ }
	~expression_generic()
	{
		int null[] = {
			delete (Args*)arguments[i]
		};
	}*//*
	// it coudl be nic to have the syntax_operator_identifier available as a template parameter.  for compile-time-balance.
	template <typename Void, syntax_operator_identifier suboperation, typename ... SubArgs>
	auto syntax_operate(SubArgs & ... subargs)
	{
		return expression_generic<suboperation, expression_generic<operation, Args...>,SubArgs...>(*this, subargs ...);
	}
};
*/

#if 0

// optional simple cmp implementation for any
#ifndef NO_ANY_CMP
int cmp(std::any const & left, std::any const & right)
{
	if (left.type() != right.type()) { return left.type().before(right.type()) ? -1 : 1; }
	#define type_case(type_name) \
		else if (left.type() == typeid(type_name)) { \
			return *std::any_cast<type_name>(&right) - *std::any_cast<type_name>(&left); \
		}
	type_case(bool)
	type_case(char)
	type_case(short)
	type_case(int)
	type_case(long)
	type_case(long long)
	type_case(unsigned char)
	type_case(unsigned short)
	type_case(unsigned int)
	type_case(unsigned long)
	type_case(unsigned long long)
	type_case(float)
	type_case(double)
	type_case(long double)
	else {
		throw "unimplemented";
	}
	#undef __type_case
}
#endif

// cmp can be used to quickly implement comparators for a type
template <typename A, typename B>
bool operator==(A const & left, B const & right)
{ return cmp(left, right) == 0; }
template <typename A, typename B>
bool operator<=(A const & left, B const & right)
{ return cmp(left, right) <= 0; }
template <typename A, typename B>
bool operator>=(A const & left, B const & right)
{ return cmp(left, right) >= 0; }
template <typename A, typename B>
bool operator<(A const & left, B const & right)
{ return cmp(left, right) < 0; }
template <typename A, typename B>
bool operator>(A const & left, B const & right)
{ return cmp(left, right) > 0; }

// cmp for vectors
template <typename T>
int cmp(std::vector<T> const & left, std::vector<T> const & right)
{
	if (left.size() != right.size()) { return false; }
	for (size_t i = 0; i < left.size(); ++ i)
	{
		if (i >= right.size()) { return 1; }
		int result = cmp(left[i], right[i]);
		if (result != 0) { return result; }
	}
	if (left.size() < right.size()) { return -1; }
	return 0;
}

// cmp-based comparators for vectors
template <typename T>
bool operator==(std::vector<T> const & left, std::vector<T> const & right)
{ return cmp(left, right) == 0; }
template <typename T>
bool operator<=(std::vector<T> const & left, std::vector<T> const & right)
{ return cmp(left, right) <= 0; }
template <typename T>
bool operator>=(std::vector<T> const & left, std::vector<T> const & right)
{ return cmp(left, right) >= 0; }
template <typename T>
bool operator<(std::vector<T> const & left, std::vector<T> const & right)
{ return cmp(left, right) < 0; }
template <typename T>
bool operator>(std::vector<T> const & left, std::vector<T> const & right)
{ return cmp(left, right) > 0; }
#endif

} // namespace expressions
